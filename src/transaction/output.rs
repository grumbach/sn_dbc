// Copyright (c) 2023, MaidSafe.
// All rights reserved.
//
// This SAFE Network Software is licensed under the BSD-3-Clause license.
// Please see the LICENSE file for more details.

use bls_bulletproofs::{
    blstrs::{G1Projective, Scalar},
    group::ff::Field,
    group::GroupEncoding,
    merlin::Transcript,
    rand::{CryptoRng, RngCore},
    BulletproofGens, PedersenGens, RangeProof,
};
use blsttc::PublicKey;
use std::{cmp::Ordering, collections::BTreeSet};
use tiny_keccak::{Hasher, Sha3};

#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};

use super::{Error, Input, Result, RevealedCommitment, RevealedInput};
pub(super) const RANGE_PROOF_BITS: usize = 64; // note: Range Proof max-bits is 64. allowed are: 8, 16, 32, 64 (only)
                                               //       This limits our amount field to 64 bits also.
pub(super) const RANGE_PROOF_PARTIES: usize = 1; // The maximum number of parties that can produce an aggregated proof
pub(super) const MERLIN_TRANSCRIPT_LABEL: &[u8] = b"SN_DBC";

use crate::Commitment;

/// Represents a Dbc's value.
pub type Amount = u64;

#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[derive(Debug, Clone)]
pub struct Output {
    pub public_key: PublicKey,
    pub amount: Amount,
}

impl Output {
    pub fn new<G: Into<PublicKey>>(public_key: G, amount: Amount) -> Self {
        Self {
            public_key: public_key.into(),
            amount,
        }
    }

    pub fn public_key(&self) -> PublicKey {
        self.public_key
    }

    pub fn amount(&self) -> Amount {
        self.amount
    }

    /// Generate a commitment to the input amount
    pub fn random_commitment(&self, rng: impl RngCore) -> RevealedCommitment {
        RevealedCommitment::from_value(self.amount, rng)
    }
}

#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[derive(Debug, Clone)]
struct RevealedOutputCommitment {
    pub public_key: PublicKey,
    pub revealed_commitment: RevealedCommitment,
}

#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[derive(Debug, Clone, Default)]
pub struct RevealedTransaction {
    pub inputs: Vec<RevealedInput>,
    pub outputs: Vec<Output>,
}

impl RevealedTransaction {
    pub fn sign(
        &self,
        mut rng: impl RngCore + CryptoRng,
    ) -> Result<(DbcTransaction, Vec<RevealedCommitment>)> {
        // We need to gather a bunch of things for our message to sign.
        //   All public keys in all inputs
        //   All input commitments
        //   All output public keys.
        //   All output commitments
        //   All output range proofs
        //
        //   notes:
        //     1. output commitments, range_proofs, and public_keys are bundled
        //        together in OutputProofs
        let revealed_input_commitments = self.revealed_input_commitments();
        let input_commitments = self.input_commitments();

        let revealed_output_commitments =
            self.revealed_output_commitments(&revealed_input_commitments, &mut rng);
        let output_proofs = self.output_range_proofs(&revealed_output_commitments, &mut rng)?;

        // Generate message to sign.
        // note: must match message generated by DbcTransaction::verify()
        let msg = gen_message_for_signing(&self.public_keys(), &input_commitments, &output_proofs);

        // We create a signature for each input
        let signed_inputs: Vec<Input> = self
            .inputs
            .iter()
            .map(|input| input.sign(&msg, &Self::pc_gens()))
            .collect();

        let revealed_output_commitments = revealed_output_commitments
            .iter()
            .map(|r| r.revealed_commitment)
            .collect::<Vec<_>>();

        Ok((
            DbcTransaction {
                inputs: signed_inputs,
                outputs: output_proofs,
            },
            revealed_output_commitments,
        ))
    }

    fn bp_gens() -> BulletproofGens {
        BulletproofGens::new(RANGE_PROOF_BITS, RANGE_PROOF_PARTIES)
    }

    fn pc_gens() -> PedersenGens {
        Default::default()
    }

    pub fn public_keys(&self) -> Vec<PublicKey> {
        self.inputs.iter().map(|input| input.public_key()).collect()
    }

    fn revealed_input_commitments(&self) -> Vec<RevealedCommitment> {
        self.inputs
            .iter()
            .map(|input| *input.revealed_commitment())
            .collect()
    }

    fn input_commitments(&self) -> Vec<Commitment> {
        self.inputs
            .iter()
            .map(|input| input.commitment(&Self::pc_gens()))
            .collect()
    }

    fn revealed_output_commitments(
        &self,
        revealed_input_commitments: &[RevealedCommitment],
        mut rng: impl RngCore,
    ) -> Vec<RevealedOutputCommitment> {
        // avoid subtraction underflow in next step.
        if self.outputs.is_empty() {
            return vec![];
        }

        let mut revealed_output_commitments: Vec<RevealedOutputCommitment> = self
            .outputs
            .iter()
            .map(|out| RevealedOutputCommitment {
                public_key: out.public_key,
                revealed_commitment: out.random_commitment(&mut rng),
            })
            .take(self.outputs.len() - 1)
            .collect();

        // todo: replace fold() with sum() when supported in blstrs
        let input_sum: Scalar = revealed_input_commitments
            .iter()
            .map(RevealedCommitment::blinding)
            .fold(Scalar::zero(), |sum, x| sum + x);

        // todo: replace fold() with sum() when supported in blstrs
        let output_sum: Scalar = revealed_output_commitments
            .iter()
            .map(|r| r.revealed_commitment.blinding())
            .fold(Scalar::zero(), |sum, x| sum + x);

        let output_blinding_correction = input_sum - output_sum;

        if let Some(last_output) = self.outputs.last() {
            revealed_output_commitments.push(RevealedOutputCommitment {
                public_key: last_output.public_key,
                revealed_commitment: RevealedCommitment {
                    value: last_output.amount,
                    blinding: output_blinding_correction,
                },
            });
        } else {
            panic!("Expected at least one output")
        }
        revealed_output_commitments
    }

    fn output_range_proofs(
        &self,
        revealed_output_commitments: &[RevealedOutputCommitment],
        mut rng: impl RngCore + CryptoRng,
    ) -> Result<Vec<OutputProof>> {
        let mut prover_ts = Transcript::new(MERLIN_TRANSCRIPT_LABEL);

        let bp_gens = Self::bp_gens();

        revealed_output_commitments
            .iter()
            .map(|c| {
                let (range_proof, commitment) = RangeProof::prove_single_with_rng(
                    &bp_gens,
                    &Self::pc_gens(),
                    &mut prover_ts,
                    c.revealed_commitment.value,
                    &c.revealed_commitment.blinding,
                    RANGE_PROOF_BITS,
                    &mut rng,
                )?;

                Ok(OutputProof {
                    public_key: c.public_key,
                    range_proof,
                    commitment,
                })
            })
            .collect::<Result<Vec<_>>>()
    }
}

// note: used by both RevealedTransaction::sign and DbcTransaction::verify()
//       which must match.
fn gen_message_for_signing(
    public_keys: &[PublicKey],
    input_commitments: &[Commitment],
    output_proofs: &[OutputProof],
) -> Vec<u8> {
    // Generate message to sign.
    let mut msg: Vec<u8> = Default::default();
    msg.extend("public_keys".as_bytes());
    for pk in public_keys.iter() {
        msg.extend(pk.to_bytes().as_ref());
    }
    msg.extend("commitments".as_bytes());
    for r in input_commitments.iter() {
        msg.extend(r.to_bytes().as_ref());
    }
    msg.extend("output_proofs".as_bytes());
    for o in output_proofs.iter() {
        msg.extend(o.to_bytes());
    }
    msg.extend("end".as_bytes());
    msg
}

#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[derive(Eq, PartialEq, Debug, Clone)]
pub struct OutputProof {
    public_key: PublicKey,
    range_proof: RangeProof,
    commitment: Commitment,
}

impl OutputProof {
    pub fn to_bytes(&self) -> Vec<u8> {
        let mut v: Vec<u8> = Default::default();
        v.extend(self.public_key.to_bytes().as_ref());
        v.extend(&self.range_proof.to_bytes());
        v.extend(self.commitment.to_bytes().as_ref());
        v
    }

    pub fn public_key(&self) -> &PublicKey {
        &self.public_key
    }

    pub fn range_proof(&self) -> &RangeProof {
        &self.range_proof
    }

    pub fn commitment(&self) -> Commitment {
        self.commitment
    }
}

#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[derive(Eq, PartialEq, Debug, Clone)]
pub struct DbcTransaction {
    pub inputs: Vec<Input>,
    pub outputs: Vec<OutputProof>,
}

impl PartialOrd for DbcTransaction {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for DbcTransaction {
    fn cmp(&self, other: &Self) -> Ordering {
        self.hash().cmp(&other.hash())
    }
}

impl DbcTransaction {
    pub fn to_bytes(&self) -> Vec<u8> {
        let mut v: Vec<u8> = Default::default();
        v.extend("inputs".as_bytes());
        for m in self.inputs.iter() {
            v.extend(&m.to_bytes());
        }
        v.extend("outputs".as_bytes());
        for o in self.outputs.iter() {
            v.extend(&o.to_bytes());
        }
        v.extend("end".as_bytes());
        v
    }

    pub fn hash(&self) -> [u8; 32] {
        let mut sha3 = Sha3::v256();

        sha3.update(&self.to_bytes());

        let mut hash = [0; 32];
        sha3.finalize(&mut hash);
        hash
    }

    // note: must match message generated by RevealedTransaction::sign()
    pub fn gen_message(&self) -> Vec<u8> {
        // All public keys
        let public_keys: Vec<PublicKey> = self.inputs.iter().map(|m| m.public_key).collect();

        // All input commitments
        let input_commitments: Vec<Commitment> = self.inputs.iter().map(|i| i.commitment).collect();

        gen_message_for_signing(&public_keys, &input_commitments, &self.outputs)
    }

    pub fn verify(&self, public_commitments: &[Commitment]) -> Result<()> {
        // check input sigs
        let msg = self.gen_message();
        for (input, commit) in self.inputs.iter().zip(public_commitments) {
            input.verify(&msg, *commit)?
        }

        let mut prover_ts = Transcript::new(MERLIN_TRANSCRIPT_LABEL);
        let bp_gens = RevealedTransaction::bp_gens();

        for output in self.outputs.iter() {
            // Verification requires a transcript with identical initial state:
            output.range_proof.verify_single(
                &bp_gens,
                &RevealedTransaction::pc_gens(),
                &mut prover_ts,
                &output.commitment,
                RANGE_PROOF_BITS,
            )?;
        }

        // Verify that the tx has at least one input
        if self.inputs.is_empty() {
            return Err(Error::TransactionMustHaveAnInput);
        }

        // Verify that each public_key is unique
        let pk_count = self.inputs.len();
        let pk_unique: BTreeSet<_> = self.inputs.iter().map(|input| input.public_key).collect();
        if pk_unique.len() != pk_count {
            return Err(Error::PublicKeyNotUniqueAcrossInputs);
        }

        // check that the inputs equal the outputs (with commitments)
        let input_sum: G1Projective = self
            .inputs
            .iter()
            .map(|i| i.commitment)
            .map(G1Projective::from)
            .sum();
        let output_sum: G1Projective = self
            .outputs
            .iter()
            .map(OutputProof::commitment)
            .map(G1Projective::from)
            .sum();

        if input_sum != output_sum {
            Err(Error::InputPseudoCommitmentsDoNotSumToOutputCommitments)
        } else {
            Ok(())
        }
    }
}

#[cfg(test)]
mod tests {
    use std::{collections::BTreeMap, iter::FromIterator};

    use bls_bulletproofs::{
        blstrs::G1Affine,
        group::Group,
        rand::{self, rngs::OsRng},
    };
    use blsttc::{IntoFr, SecretKey};

    use crate::RevealedInput;

    use super::*;

    #[derive(Default)]
    struct TestLedger {
        commitments: BTreeMap<[u8; 48], Commitment>, // Compressed public keys -> Commitments
    }

    impl TestLedger {
        fn log(&mut self, public_key: impl Into<G1Affine>, commitment: impl Into<G1Affine>) {
            self.commitments
                .insert(public_key.into().to_compressed(), commitment.into());
        }

        fn lookup(&self, public_key: impl Into<G1Affine>) -> Option<G1Affine> {
            self.commitments
                .get(&public_key.into().to_compressed())
                .copied()
        }
    }

    #[test]
    fn test_input_sign() {
        let mut rng = OsRng::default();
        let pc_gens = PedersenGens::default();

        let input_sk_seed: u64 = rand::random();
        let true_input = RevealedInput {
            secret_key: SecretKey::from_mut(&mut input_sk_seed.into_fr()),
            revealed_commitment: RevealedCommitment {
                value: 3,
                blinding: 5.into(),
            },
        };

        let mut ledger = TestLedger::default();
        ledger.log(
            true_input.public_key(),
            true_input.revealed_commitment.commit(&pc_gens),
        );
        ledger.log(
            G1Projective::random(&mut rng),
            G1Projective::random(&mut rng),
        );
        ledger.log(
            G1Projective::random(&mut rng),
            G1Projective::random(&mut rng),
        );

        let output_sk_seed: u64 = rand::random();
        let revealed_tx = RevealedTransaction {
            inputs: vec![true_input],
            outputs: vec![Output {
                public_key: SecretKey::from_mut(&mut output_sk_seed.into_fr()).public_key(),
                amount: 3,
            }],
        };

        let (signed_tx, _revealed_output_commitments) =
            revealed_tx.sign(rng).expect("Failed to sign transaction");

        let public_commitments = Vec::from_iter(
            signed_tx
                .inputs
                .iter()
                .map(|input| ledger.lookup(input.public_key()).unwrap()),
        );

        assert!(signed_tx.verify(&public_commitments).is_ok());
    }
}
